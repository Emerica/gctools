#!/usr/bin/env python
#----------------------------------------------------------------------------
# 13-Nov-2014 ShaneG
#
# Some slight changes to the code for consistancy with the output generated
# by 'linegrinder'. The origin is now in the lower left corner, x increments
# upwards, y increments to the right. The boards are now treated with the
# same origin location (this is what linegrinder generates).
#
# Rotations are in the counter clockwise direction with the working origin
# at the bottom left corner which moves the source origin to the bottom
# right.
#
# 11-Nov-2014 ShaneG
#
# Tool to pack multiple PCB g-code files into a single panel.
#----------------------------------------------------------------------------
from os.path import exists, isfile, abspath
from subprocess import Popen, PIPE
from sys import argv
from PIL import Image, ImageDraw
from math import sqrt, radians, sin, cos, atan;
import re;

# File name suffix (as generated by linegrinder)
SUFFIX = (
  "_ISOLATION_GCODE.ngc",
  "_DRILL_GCODE.ngc",
  "_EDGEMILL_GCODE.ngc",
  )

# Program names
GRECODE = "grecode"
OPTIMISER = "opti"

# Default parameters
PANEL_WIDTH   = 145.0
PANEL_HEIGHT  = 70.0
PANEL_SPACING = 3.0
OPTIMISE      = True

# Drill code prefix lines
DRILL_PREFIX = (
  "G20 (Use Inches)",
  "G90 (Set Absolute Coordinates)",
  "G17 (XY plane selection)",
  "G00 Z0.25",
  "G00 X0 Y0",
  "M03 (Start spindle)",
  "G04 P1 (Pause to let the spindle start)",
  )

DRILL_SUFFIX = (
  "M05 (Stop spindle)",
  "M02 (Program End)",
  )

#----------------------------------------------------------------------------
# Repair arcs
#
# Line Grinder can generate files with invalid arc commands (the end-point
# radius differs from the start-point radius). This code implements a filter
# to repair that. Original: https://github.com/blinkenlight/LineBender
#----------------------------------------------------------------------------


# ******************************************************************************
# Global variables
# ******************************************************************************

TextLinesHandled = 0;                                                           # Number of lines of g-code analyzed (should match the number of lines of text in the file)
TextLinesIgnored = 0;                                                           # Number of lines of g-code ignored (because no G0/G1/G2/G3 or X/Y/Z was found on the line)

PathLinesHandled = 0;                                                           # Number of path lines analyzed (number of lines found containing a G0/G1/G2/G3)
PathLinesDropped = 0;                                                           # Number of path lines removed as too short (Line Grinder uses these). Not implemented in 0.1
PathArcsAdjusted = 0;                                                           # Number of arc path lines recalculated (all arcs, currently, whether really needed or not)
PathArcsUnedited = 0;                                                           # Number of arc path lines NOT recalculated: any full circles (sole exceptions, see above )

UnitsMode = None;                                                               # Tracks current units mode (metric/imperial). Not implemented in 0.1
CoordsMode = None;                                                              # Tracks current coordinate mode (absolute/relative). Not implemented in 0.1
WorkPlane = None;                                                               # Tracks current work plane (XY/XZ/YZ). Not implemented in 0.1

CurrentPosition = {'X': None, 'Y': None, 'Z': None};                            # This tracks current X/Y/Z position at all times to be used as starting point for arcs

def logDebug(msg):
  #print "DEBUG: %s" % msg
  pass

def logError(msg):
  print "ERROR: %s" % msg

def sqr(x):
  """ Return number squared
  """
  return(x*x);

def dist(Xa, Ya, Xb, Yb):
  """ Calculate distance between two points.
  """
  return(sqrt(sqr(Xa - Xb) + sqr(Ya - Yb)));

def BendThatArc(X0, Y0, X1, Y1, X2, Y2):
  """ Does the actual math to recalculate the arc's center

    Note: X0,Y0 = arc start, X1,Y1 = arc end, X2,Y2 = original arc center
    Also, the proverbial compulsory bug in every software probably lives in here

    To briefly explain what's going on below, try to imagine solving it this way:
    In a custom coordinate system where both arc endpoints are on the "X" axis
    and the "Y" axis passes exactly halfway between them, the solution for the
    center of the arc is trivial: X=0, and Y is found as one side in the right
    angled triangle in which the distance to the arc endpoints is the hypotenuse
    and is fixed as the arc radius, while the other side is half the distance
    between the endpoints. Once we have this (X, Y) for the center, it's just a
    matter of (roto-)translating our custom coordinate system onto the actual
    frame of reference - not hard once we find the coordinates of the middle
    point of the segment connecting the arc's endpoints and the angle that
    segment makes with the horizontal ("X"-axis) of the "real" reference frame.
    In fact, some of you might recognize the trigonometric bit towards the end
    as a specific form of the general equations for transforming coordinate
    systems. There are two possible solutions - we pick the one we like more...
  """
  R = dist(X0, Y0, X2, Y2);                        # Radius we want to keep for the arc (equal to the original arc's radius)
  T = dist(X0, Y0, X1, Y1) / 2;                    # Half of the distance between the arc's endpoints (half length of the segment connecting them)
  S = sqrt(abs(sqr(R) - sqr(T)));                       # Center's distance from the midpoint on the perpendicular that goes through it (in either direction)
  Xm = (X0 + X1) / 2;                              # Coordinates of the above-mentioned midpoint of the segment connecting the arc's endpoints
  Ym = (Y0 + Y1) / 2;                              # These are our translation coordinates for the reference frame transformation
  if X0 == X1:                                     # Now we just need the angle between our custom and the global reference frame
      alfa = radians(90);                          # We'd rather avoid a division by zero for the alfa = 90 degrees case (endpoints on the same vertical)
  else:
      alfa = atan((Y1 - Y0) / (X1 - X0));          # Otherwise, the "slope" of the segment connecting the arc endpoints is the angle we want
  X3 = Xm + S * sin(alfa);                         # The actual coordinate system transformation of the point (X=0, Y=S) into the real reference frame
  Y3 = Ym - S * cos(alfa);
  X4 = Xm - S * sin(alfa);                         # The other possible solution.
  Y4 = Ym + S * cos(alfa);
  if dist(X2, Y2, X3, Y3) < dist(X2, Y2, X4, Y4):  # Cheating bigtime: there are inherently two centers that would fit two endpoints and a radius.
    return(X3, Y3);                                # Finding the proper one would entail figuring out the tangents at the endpoints of the arc
  else:                                            # which in turn would mean looking behind and ahead further for the adjoining segments.
    return(X4, Y4);                                # Instead, we simply choose the solution closer to the original center...

def AdjustArc(Position, Values, Params):
  """ AdjustArc() - recalculate origin (I,J) to match start and end points better

  Note: Arcs in non-XY planes...? K...? Heeey, where is everyone going...?!?
  """
  global PathArcsUnedited;
  Xs = Position['X'];                                                         # Coordinates of the starting point for the arc
  Ys = Position['Y'];
  if Values['X'] is not None:                                                 # Update the arc end point X coordinate if there is one on this line of code,
    Xe = Values['X'];
  else:                                                                       # otherwise just use the current one
    Xe = Xs;
  if Values['Y'] is not None:                                                 # Update the arc end point Y coordinate if there is one on this line of code,
    Ye = Values['Y'];
  else:
    Ye = Ys;                                                                # otherwise just use the current one
  if Values['I'] is not None:                                                 # Calculate the absolute arc center X coordinate from the relative I if there is one on this line of code,
    Xc = Xs + Values['I'];
  else:
    Xc = Xs;                                                                # otherwise just use the current X
  if Values['J'] is not None:                                                 # Calculate the absolute arc center Y coordinate from the relative I if there is one on this line of code,
    Yc = Ys + Values['J'];
  else:
    Yc = Ys;                                                                # otherwise just use the current Y
  if  dist(Xs, Ys, Xe, Ye) > 0:                                               # Cannot recalculate full circle arcs from endpoint(s) and radius; thankfully, there's no need either - they're always valid
    NewXc, NewYc = BendThatArc(Xs, Ys, Xe, Ye, Xc, Yc);                     # Do the magic, get some new center coordinates
    NewI = NewXc - Xs;                                                      # Calculate the relative I/J members from the absolute center X/Y
    NewJ = NewYc - Ys;
    if Params['N'] is None:                                                 # If there is no line number,
      LineNumberString = "";                                              # set the line number string to empty
    else:                                                                   # If there is one,
      LineNumberString = " (aka \"N" + Params['N'] + "\")";               # form a string to be included in any messages referring to this line
    OldCoordString = "[{0:.4f}, {1:.4f}]".format(Xc, Yc);
    NewCoordString = "[{0:.4f}, {1:.4f}]".format(NewXc, NewYc);
    logDebug("Adjusting center of arc from line {0}".format(TextLinesHandled) + LineNumberString + " from " + OldCoordString + " to " + NewCoordString);
    CommentString = " (Center moved by Line Bender from " + OldCoordString + " to " + NewCoordString + ")\n";
  else:                                                                       # If this arc is a full circle, we have to skip it
    NewI = Values['I'];                                                     # so the original center is preserved as the "new" one
    NewJ = Values['J'];
    PathArcsUnedited += 1;                                                  # Count this arc as skipped
    if Params['N'] is None:                                                 # If there is no line number,
      LineNumberString = "";                                              # set the line number string to empty
    else:                                                                   # If there is one,
      LineNumberString = " (aka \"N" + Params['N'] + "\")";               # form a string to be included in any messages referring to this line
    logDebug("Preserving center of arc from line {0}".format(TextLinesHandled) + LineNumberString + " - center cannot be determined for full circles");
    CommentString = " (Center preserved by Line Bender - center cannot be determined for full circles)\n";
  # *** This is also fudged(more corner cutting). It could use a bit of customization depending on which params are present and/or unchanged, no?
  NewLine = "G" + Params['G'] + " X{0:.4f} Y{1:.4f} I{2:.4f} J{3:.4f}".format(Xe, Ye, NewI, NewJ) + CommentString;
  return(NewLine);                                                            # Return the newly recalculated arc as a text line to replace the old line of g-code

def ScanForParams(WorkLine):
  """ Split the line into code words, return a dictionary of them

  Note: Only one instance of each word per line is handled right now even though
  multiple ones are quite legal (but not common in machine-generated g-code);
  The elements in the dictionary are either 'None' or the single string value.
  Also, it's hardly optimal to look for everyting on every line. I know. Sorry.
  """
  WorkLine = re.sub(";.*", "", WorkLine);                                     # Zap any semicolon-type comments (from semicolon to the end of the line)
  WorkLine = re.sub("\(.*?\)", "", WorkLine);                                 # Yank any parentheses-based comments (only whatever is between any parenthesis sets)
  WorkLine = re.sub(" |\t", "", WorkLine);                                    # We also Kick all tabs and spaces (why? BECAUSE WE CAN...!)
  # *** N-words **********************
  NWords = re.search("N(\d+)", WorkLine, re.IGNORECASE);                      # Search for a "Nxx" style line number. Only the first occurence, sorry...
  if NWords is None:                                                          # If no N-word is found,
    NParam = None;                                                          # set the return value to 'None',
    LineNumberString = "";                                                  # and the line number string to empty
  else:                                                                       # If one is found,
    NParam = NWords.group(1);                                               # store its parameter to be returned,
    LineNumberString = " (aka \"N" + NParam + "\")";                        # and form a string to be included in any messages referring to this line
  CommonErrorString = " on line {0}".format(TextLinesHandled) + LineNumberString + ", exiting.";
  # *** G-words **********************
  GWords = re.findall("G(\d+)", WorkLine, re.IGNORECASE);                     # Find all "Gxx" style codes (just the values)
  if len(GWords) > 1:                                                         # If there are multiple G-words on this line, we're busted, sorry...
    logError("Multiple \"G\" words found" + CommonErrorString);
    sys.exit(1);
  elif len(GWords) > 0:                                                       # If there is one, store its parameter to be returned,
    GParam = GWords[0];
  else:                                                                       # If there are none, set the return value accordingly
    GParam = None;
  # *** M-words **********************
  MWords = re.findall("M(\d+)", WorkLine, re.IGNORECASE);                     # Find all "Mxx" style codes (just the values)
  if len(MWords) > 1:                                                         # If there are multiple M-words on this line, we're busted, sorry...
    logError("Multiple \"M\" words found" + CommonErrorString);
    sys.exit(1);
  elif len(MWords) > 0:                                                       # If there is one, store its parameter to be returned,
    MParam = MWords[0];
  else:                                                                       # If there are none, set the return value accordingly
    MParam = None;
  # *** F-words **********************
  FWords = re.findall("F([+-]{,1}[\d.]+)", WorkLine, re.IGNORECASE);          # Find all "Fxx" style codes possibly including sign and decimal point (only values)
  if len(FWords) > 1:                                                         # If there are multiple F-words on this line, we're busted, sorry...
    logError("Multiple \"F\" words found" + CommonErrorString);
    sys.exit(1);
  elif len(FWords) > 0:                                                       # If there is one, store its parameter to be returned,
    FParam = FWords[0];
  else:                                                                       # If there are none, set the return value accordingly
    FParam = None;
  # *** X-words **********************
  XWords = re.findall("X([+-]{,1}[\d.]+)", WorkLine, re.IGNORECASE);          # Find all "Xxxx" style codes possibly including sign and decimal point (only values)
  if len(XWords) > 1:                                                         # If there are multiple X-words on this line, we're busted, sorry...
    logError("Multiple \"X\" words found" + CommonErrorString);
    sys.exit(1);
  elif len(XWords) > 0:                                                       # If there is one, store its parameter to be returned,
    XParam = XWords[0];
  else:                                                                       # If there are none, set the return value accordingly
    XParam = None;
  # *** Y-words **********************
  YWords = re.findall("Y([+-]{,1}[\d.]+)", WorkLine, re.IGNORECASE);          # Find all "Yxxx" style codes possibly including sign and decimal point (only values)
  if len(YWords) > 1:                                                         # If there are multiple Y-words on this line, we're busted, sorry...
    logError("Multiple \"Y\" words found" + CommonErrorString);
    sys.exit(1);
  elif len(YWords) > 0:                                                       # If there is one, store its parameter to be returned,
    YParam = YWords[0];
  else:                                                                       # If there are none, set the return value accordingly
    YParam = None;
  # *** Z-words **********************
  ZWords = re.findall("Z([+-]{,1}[\d.]+)", WorkLine, re.IGNORECASE);          # Find all "Zxxx" style codes possibly including sign and decimal point (only values)
  if len(ZWords) > 1:                                                         # If there are multiple Z-words on this line, we're busted, sorry...
    logError("Multiple \"Z\" words found" + CommonErrorString);
    sys.exit(1);
  elif len(ZWords) > 0:                                                       # If there is one, store its parameter to be returned,
    ZParam = ZWords[0];
  else:                                                                       # If there are none, set the return value accordingly
    ZParam = None;
  # *** I-words **********************
  IWords = re.findall("I([+-]{,1}[\d.]+)", WorkLine, re.IGNORECASE);          # Find all "Ixxx" style codes possibly including sign and decimal point (only values)
  if len(IWords) > 1:                                                         # If there are multiple I-words on this line, we're busted, sorry...
    logError("Multiple \"I\" words found" + CommonErrorString);
    sys.exit(1);
  elif len(IWords) > 0:                                                       # If there is one, store its parameter to be returned,
    IParam = IWords[0];
  else:                                                                       # If there are none, set the return value accordingly
    IParam = None;
  # *** J-words **********************
  JWords = re.findall("J([+-]{,1}[\d.]+)", WorkLine, re.IGNORECASE);          # Find all "Jxxx" style codes possibly including sign and decimal point (only values)
  if len(JWords) > 1:                                                         # If there are multiple J-words on this line, we're busted, sorry...
    logError("Multiple \"J\" words found" + CommonErrorString);
    sys.exit(1);
  elif len(JWords) > 0:                                                       # If there is one, store its parameter to be returned,
    JParam = JWords[0];
  else:                                                                       # If there are none, set the return value accordingly
    JParam = None;
  # *** K-words **********************
  KWords = re.findall("K([+-]{,1}[\d.]+)", WorkLine, re.IGNORECASE);          # Find all "Kxxx" style codes possibly including sign and decimal point (only values)
  if len(KWords) > 1:                                                         # If there are multiple K-words on this line, we're busted, sorry...
    logError("Multiple \"K\" words found" + CommonErrorString);
    sys.exit(1);
  elif len(KWords) > 0:                                                       # If there is one, store its parameter to be returned,
    KParam = KWords[0];
  else:                                                                       # If there are none, set the return value accordingly
    KParam = None;
  # *** R-words **********************
  RWords = re.findall("R([+-]{,1}[\d.]+)", WorkLine, re.IGNORECASE);          # Find all "Rxxx" style codes possibly including sign and decimal point (only values)
  if len(RWords) > 0:                                                         # If there are any R-words on this line, it's the wrong arc format, sorry...
    logError("Radius format arc found" + CommonErrorString);
    sys.exit(1);
  Params = dict({'N': NParam, 'G': GParam, 'M': MParam, 'F': FParam, 'X': XParam, 'Y': YParam, 'Z': ZParam, 'I': IParam, 'J': JParam, 'K': KParam});
  return(Params);

def WordsToValues(Params):
  """ Convert relevant string G-word parameters to numeric ones
  """
  if Params['N'] is None:                                                     # If there is no N-word,
    LineNumberString = "";                                                  # set the line number string to empty
  else:                                                                       # If there is one,
    LineNumberString = " (aka \"N" + Params['N'] + "\")";                   # form a string to be included in any messages referring to this line
  CommonErrorString = " on line {0}".format(TextLinesHandled) + LineNumberString + ", exiting.";
  try:
    if Params['G'] is None:                                                 # If it exists, convert the parameter to a number
      GValue = None;
    else:
      GValue = int(Params['G']);
    if Params['M'] is None:                                                 # If it exists, convert the parameter to a number
      MValue = None;
    else:
      MValue = int(Params['M']);
    if Params['X'] is None:                                                 # If it exists, convert the parameter to a number
      XValue = None;
    else:
      XValue = float(Params['X']);
    if Params['Y'] is None:                                                 # If it exists, convert the parameter to a number
      YValue = None;
    else:
      YValue = float(Params['Y']);
    if Params['Z'] is None:                                                 # If it exists, convert the parameter to a number
      ZValue = None;
    else:
      ZValue = float(Params['Z']);
    if Params['I'] is None:                                                 # If it exists, convert the parameter to a number
      IValue = None;
    else:
      IValue = float(Params['I']);
    if Params['J'] is None:                                                 # If it exists, convert the parameter to a number
      JValue = None;
    else:
      JValue = float(Params['J']);
    if Params['K'] is None:                                                 # If it exists, convert the parameter to a number
      KValue = None;
    else:
      KValue = float(Params['K']);
  except:
    logError("A numeric conversion failed" + CommonErrorString);
    sys.exit(1);
  Values = dict({'G': GValue, 'M': MValue, 'X': XValue, 'Y': YValue, 'Z': ZValue, 'I': IValue, 'J': JValue, 'K': KValue});
  return(Values);

# ******************************************************************************
# ******************************************************************************

def ParseLine(CurrentLine):
  """ Parse a single line, return an adjusted arc or the original line

  I'm well aware exiting like this on any error without closing stuff is not
  exactly nice but I'm learning all of this right now, and I have a half-done
  PCB I can't engrave waiting (hopefully still aligned) on the mill table, ok?
  """
  global TextLinesHandled;                                                    # Stuff to be updated from this function needs to be declared
  global TextLinesIgnored;
  global PathLinesHandled;
  global PathLinesDropped;
  global PathArcsAdjusted;
  global UnitsMode;
  global CoordsMode;
  global WorkPlane;
  global CurrentPosition;
  TextLinesHandled += 1;                                                      # Mark processing another line of text
  IgnoringThisLine = True;                                                    # Assume it will be ignored unless found otherwise
  GParams = ScanForParams(CurrentLine);                                       # Retrieve any relevant G-words from the line (values only, as string)
  GValues = WordsToValues(GParams);                                           # Some parameters are more useful as numbers, some as strings: converting
  # *** OK, really starting to cut corners here. This should be rather more generalized. Needs rewriting AFTER that PCB is done.
  # *** For now, I'm assuming arc start point is never "unset" / imperial, absolute mode in plane XY, full stop. Sorry.
  if GValues['G'] == 0 or GValues['G'] == 1:                                  # Handle G0/G1 lines (does nothing as of 0.1)
    PathLinesHandled += 1;
    IgnoringThisLine = False;
  if GValues['G'] == 2 or GValues['G'] == 3:                                  # Handle G2/G3 lines (the point of all this)
    CurrentLine = AdjustArc(CurrentPosition, GValues, GParams);             # Get a new line instead of the old one with a recalculated center
    PathArcsAdjusted += 1;
    IgnoringThisLine = False;
  if GValues['X'] is not None:                                                # Harvest any new X-coordinate to update the current position
    CurrentPosition['X'] = GValues['X'];
    IgnoringThisLine = False;
  if GValues['Y'] is not None:                                                # Harvest any new Y-coordinate to update the current position
    CurrentPosition['Y'] = GValues['Y'];
    IgnoringThisLine = False;
  if GValues['Z'] is not None:                                                # Harvest any new Z-coordinate to update the current position
    CurrentPosition['Z'] = GValues['Z'];
    IgnoringThisLine = False;
  if IgnoringThisLine:                                                        # Count the line as ignored if nothing above triggered
    TextLinesIgnored += 1;
  # *** Done cutting corners. Seriously, this is supposed to be way more elaborate and discerning...
  return(CurrentLine);                                                        # Return an output line for every input line of g-code

#----------------------------------------------------------------------------
# Helper functions
#----------------------------------------------------------------------------

def repairArcs(data):
  """ Uses the routines above to repair any 'bad' arcs in the source.
  """
  # Initialise state for arc fixing
  global UnitsMode, CoordsMode, WorkPlane, CurrentPosition
  UnitsMode = None
  CoordsMode = None
  WorkPlane = None
  CurrentPosition = {'X': None, 'Y': None, 'Z': None}
  # TODO: Remove line count initialisation at a later date
  global TextLinesHandled, TextLinesIgnored, PathLinesHandled, PathLinesDropped
  global PathArcsAdjusted, PathArcsUnedited
  TextLinesHandled = 0
  TextLinesIgnored = 0
  PathLinesHandled = 0
  PathLinesDropped = 0
  PathArcsAdjusted = 0
  PathArcsUnedited = 0
  # Now process the data
  result = list()
  for line in data:
    result.append(ParseLine(line))
  # TODO: Remove this later, I want to see what it is doing for now
  print u"Text lines handled: {0:>8}".format(TextLinesHandled);                # Display some processing stats
  print u"Text lines ignored: {0:>8}".format(TextLinesIgnored);
  print u"Path lines handled: {0:>8}".format(PathLinesHandled);
  print u"Path lines dropped: {0:>8}".format(PathLinesDropped);
  print u"Path arcs adjusted: {0:>8}".format(PathArcsAdjusted);
  print u"Path arcs unedited: {0:>8}".format(PathArcsUnedited);
  print;
  return result

def runTool(tool, args, data, stderr = False):
  """ Run a tool with the given args and input data.
  """
  cmdline = "%s %s" % (tool, args)
#  print "Running command:\n  %s" % cmdline
  prog = Popen(cmdline, stdin=PIPE, stdout=PIPE, stderr=PIPE, shell=True)
  out, err = prog.communicate("".join(data))
  if stderr and (len(err) > 0):
    print err
  # Turn the output into a list of lines, strip blanks and 'Program Stop' (M02)
  lines = list()
  for line in out.split('\n'):
    line = line.strip()
    if (len(line) > 0) and (not line.startswith("M02")):
      lines.append(line + "\n")
  # Done
  return lines

def checkFiles(name):
  """ Given a base name, verify that all files exist
  """
  for s in SUFFIX:
    fullname = abspath(name + s)
    if not isfile(fullname):
      return False
  return True

def getCodeFile(name, filetype):
  """ Get the full name for a file
  """
  return abspath(name + SUFFIX[filetype])

def getBoardSize(name):
  # Determine the size of the board (using the edge mill)
  min_x = 1000
  max_x = -1000
  min_y = 1000
  max_y = -1000
  units = 1.0 # 1 = mm, 25.4 = inch
  edge = open(getCodeFile(name, 2), "r")
  for line in edge:
    line = line.strip()
    if (len(line) > 1) and (line[0] == 'G'):
      parts = [ part.strip() for part in line.split(' ') ]
      # Setting units ?
      if parts[0] == "G20":
        units = 25.4
      elif parts[0] == "G21":
        units = 1.00
      elif parts[0][0] == 'G':
        # Look for X/Y components
        for part in parts:
          if len(part) > 0:
            if part[0] == 'X':
              val = units * float(part[1:])
              min_x = min(min_x, val)
              max_x = max(max_x, val)
            elif part[0] == 'Y':
              val = units * float(part[1:])
              min_y = min(min_y, val)
              max_y = max(max_y, val)
  return (min_x, min_y, max_x - min_x, max_y - min_y)

def generateDrillFile(name):
  """ Generate the drill file from the pad touch downs in the isolation
      routing file.
  """
  data = None
  with open(getCodeFile(name, 0), "r") as f:
    data = f.readlines()
  inpads = False
  points = list()
  for line in data:
    line = line.strip()
    if line == "(... pad touchdown start ...)":
      inpads = True
    elif line == "(... pad touchdown end ...)":
      inpads = False
    elif inpads and line.startswith("G00 X"):
      parts = [ part.strip() for part in line.split(' ') ]
      x = None
      y = None
      for p in parts:
        if p[0] == 'X':
          x = p[1:]
        elif p[0] == 'Y':
          y = p[1:]
      if (x is not None) and (y is not None):
        points.append((x, y))
  # Now generate the drill code
  if len(points) == 0:
    return None
  data = list(DRILL_PREFIX)
  for p in points:
    data.append("G00 X%s Y%s" % p)
    data.append("G01 Z-0.118 F5") # TODO: Should allow drill depth to be set
    data.append("G00 Z0.25") # TODO: Same for safe distance
  data.extend(DRILL_SUFFIX)
  return list([ line + "\n" for line in data ])

#----------------------------------------------------------------------------
# Class wrapper to manage boards
#----------------------------------------------------------------------------

class Board:
  """ Represents a board.

    Each board has a fixed size (width and height), a mutable location and
    a rotation flag.
  """

  def __init__(self, width, height, name = "", xoff = 0.0, yoff = 0.0):
    """ Constructor with dimensions
    """
    self.name = name
    self._width = width
    self._height = height
    self._xoff = xoff
    self._yoff = yoff
    self.reset()

  def __str__(self):
    return "Board %0.2f x %0.2f @ %0.2f, %0.2f (Rot = %s)" % (self.width, self.height, self.x, self.y, self.rotated)

  @property
  def width(self):
    if self.rotated:
      return self._height
    return self._width

  @width.setter
  def width(self, value):
    raise Exception("Cannot modify 'width' after creation")

  @property
  def height(self):
    if self.rotated:
      return self._width
    return self._height

  @height.setter
  def height(self, value):
    raise Exception("Cannot modify 'height' after creation")

  def reset(self):
    """ Restore to original (unrotated, untranslated) state
    """
    self.x = 0
    self.y = 0
    self.rotated = False

  def translate(self, dx, dy):
    self.x = self.x + dx
    self.y = self.y + dy

  def overlaps(self, other):
    """ Determine if this board overlaps another
    """
    return not (((self.x + self.width) <= other.x) or
      ((other.x + other.width) <= self.x) or
      ((self.y + self.height) <= other.y) or
      ((other.y + other.height) <= self.y))

  def contains(self, other):
    """ Determine if this board completely contains another
    """
    return ((self.x <= other.x) and
      ((self.x + self.width) >= (other.x + other.width)) and
      (self.y <= other.y) and
      ((self.y + self.height) >= (other.y + other.height)))

  def area(self):
    """ Return the area of the board
    """
    return self.width * self.height

  def clone(self, dw = 0, dh = 0):
    return Board(self._width + dw, self._height + dh, self.name, self._xoff, self._yoff)

  def getAdjustedCode(self, filetype):
    """ Apply the current translation to the code
    """
    data = None
    if filetype <> 1:
      with open(getCodeFile(self.name, filetype), "r") as f:
        data = f.readlines()
# TODO: Edgemill files need to be flipped. For now just use rectangles
#      if filetype == 2:
#        # Edgemill files need to be flipped in X
#        data = runTool(GRECODE, "-xflip", data)
#        x, y, w, h = getBoardSize(self.name)
#        print "DEBUG: Edgemill (raw)"
#        print self.name
#        print x, y, w, h
#        data = runTool(GRECODE, "-shift %0.2f 0.0" % w, data)
    else:
      # Drill files get generated, not loaded
      data = generateDrillFile(self.name)
    # Determine the translation we need
    source = ( self._xoff, self._yoff, self._xoff + self._width, self._yoff + self._height )
    if self.rotated:
      target = ( self.x + self.width, self.y, self.x, self.y + self.height )
    else:
      target = ( self.x, self.y, self.x + self.width, self.y + self.height)
    # Do the translation/rotation
    data = runTool(GRECODE, "-overlay %s %s" % ("%0.2f %0.2f %0.2f %0.2f" % source, "%0.2f %0.2f %0.2f %0.2f" % target), data)
    return data

def loadBoard(name):
  """ Create a board instance from a file
  """
  if not checkFiles(name):
    raise Exception("Missing required g-code file for board '%s'" % self.name)
  # Get the board dimensions and create the instance
  xoff, yoff, width, height = getBoardSize(name)
  return Board(width + PANEL_SPACING, height + PANEL_SPACING, name, xoff, yoff)

#----------------------------------------------------------------------------
# Generate an image of the layout
#----------------------------------------------------------------------------

def createLayoutImage(panel, boards, filename):
  img = Image.new("RGB", (int(panel.width * 2), int(panel.height * 2)), "white")
  drw = ImageDraw.Draw(img)
  for board in boards:
    drw.rectangle((int(board.x * 2), int(board.y * 2), int((board.x + board.width) * 2), int((board.y + board.height) * 2)), fill = "black")
  img.save(filename)

#----------------------------------------------------------------------------
# Layout operations
#----------------------------------------------------------------------------

def getIteration(current, boards):
  """ Generate an iteration.

    We want to test every combination of rotation, this generates an iteration
    using a bit mask.
  """
  results = list()
  for bit in range(len(boards)):
    board = boards[bit].clone()
    if (1 << bit) & current:
      board.rotated = True
    results.append(board)
  return results

def overlaps(placed, board):
  """ Determine if the board overlaps any previously placed board
  """
  for previous in placed:
    if board.overlaps(previous):
      return True
  return False

def layout(panel, boards):
  """ Layout the boards on the given panel
  """
  boards = sorted(boards, cmp = lambda x, y: cmp(x.height, y.height), reverse = True)
  placed = list()
  botright = None
  for board in boards:
    # Make sure the height is valid
    if board.height > panel.height:
      return False
    # First board always goes at bottom left
    if len(placed) == 0:
      placed.append(board)
      botright = board
      continue
    # Will this board fit above any previously placed board ?
    for previous in placed:
      board.x = previous.x
      board.y = previous.y + previous.height
      if panel.contains(board) and not overlaps(placed, board):
        placed.append(board)
        board = None
        break
    # Did we manage to put it somewhere?
    if board is None:
      continue
    # Place it next to the rightmost board
    board.x = botright.x + botright.width
    board.y = 0
    # A higher (in y) board may overlap, adjust for that
    while overlaps(placed, board):
      board.translate(1.0, 0)
    # Make sure it fits
    if not panel.contains(board):
      return False
    placed.append(board)
  # If we make it here we are done for this layout
  return True

def consumedArea(boards):
  """ Determine the area taken by the boards in the current position
  """
  return max([ b.x + b.width for b in boards]) * max([ b.y + b.height for b in boards])

#----------------------------------------------------------------------------
# Main program
#----------------------------------------------------------------------------

if __name__ == "__main__":
  # Process command line
  boards = list()
  index = 1
  while index < len(argv):
    if argv[index] == "--width":
      index = index + 1
      PANEL_WIDTH = float(argv[index])
    elif argv[index] == "--height":
      index = index + 1
      PANEL_HEIGHT = float(argv[index])
    elif argv[index] == "--space":
      index = index + 1
      PANEL_SPACING = float(argv[index])
    elif argv[index] == "--noopt":
      OPTIMISE = False
    else:
      boards.append(loadBoard(argv[index]))
    index = index + 1
  # Make sure we have some boards to work with
  if len(boards) == 0:
    print "ERROR: No boards specified."
    exit(1)
  # Create the panel we want to put the boards in
  panel = Board(PANEL_WIDTH - PANEL_SPACING, PANEL_HEIGHT - PANEL_SPACING)
  # Make sure the boards will fit the panel
  print "Checking dimensions ..."
  failed = False
  if sum([board.area() for board in boards]) > panel.area():
    print "  ERROR: This combination of boards will not fit the given panel"
    failed = True
  for board in boards:
    if ((board.width > panel.width) and (board.width > panel.height)) or ((board.height > panel.height) and (board.height > panel.width)):
      print "  ERROR: Board '%s' is too large for the given panel." % board.name
      print "         Board size is %0.2f x %0.2f, panel is %0.2f x %0.2f." % (board.width, board.height, panel.width, panel.height)
      failed = True
  if failed:
    print "  ERROR: Cannot continue with the current settings."
    exit(1)
  print "  OK"
  # Process each iteration in turn
  print "Laying out boards ..."
  best = None
  for iteration in range(2 ** len(boards)):
    candidate = getIteration(iteration, boards)
    if layout(panel, candidate):
      area = consumedArea(candidate)
      if (best is None) or (area < consumedArea(best)):
        best = candidate
        print "  Selecting iteration #%d with area %0.2f mm2" % (iteration, area)
  # Did we get a usable layout?
  if best is None:
    print "  ERROR: No suitable layout found."
    exit(1)
  # Adjust for spacing
  boards = list()
  for board in best:
    adjust = board.clone(-PANEL_SPACING, -PANEL_SPACING)
    adjust.rotated = board.rotated
    adjust.translate(board.x + PANEL_SPACING, board.y + PANEL_SPACING)
    boards.append(adjust)
  # Show the results
  print "Selected layout:"
  for board in boards:
    print "  '%s' (%0.2f x %0.2f) @ %0.2f, %0.2f - rotated = %s" % (board.name, board.width, board.height, board.x, board.y, board.rotated)
  createLayoutImage(panel, boards, "pcbpack.png")
  print "Layout image saved in 'pcbpack.png'"
  print "Generating combined g-code ..."
  for filetype in range(3):
    lines = list()
    for board in boards:
      lines.extend(board.getAdjustedCode(filetype))
    # Add a program stop
    lines.append("M02 (Program stop)\n")
    # Optimise if requested (except edgemill)
    if OPTIMISE and (filetype <> 2):
      print "  Optimising .."
      lines = runTool(OPTIMISER, "", lines)
      lines.append("M02 (Program stop)\n")
    # Repair arcs
    print "  Repairing arcs ..."
    lines = repairArcs(lines)
    # Save the file
    filename = getCodeFile("pcbpack", filetype)
    print "  %s" % filename
    with open(filename, "w") as gcode:
      for line in lines:
        gcode.write(line)
  print "Operation complete."
